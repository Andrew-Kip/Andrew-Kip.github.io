<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Unified Pressure Calculator + Resistance Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.min.css" rel="stylesheet">
  <style>
    :root{--bg:#f4f7fb;--left:#ffffff;--right:#ffffff;--accent:#2E8B57}
    body{font-family: 'Times New Roman', Times, serif;background:var(--bg);margin:0;padding:18px}
    .container{display:grid;grid-template-columns:360px 1fr;gap:16px;align-items:start}
    .panel{background:#fff;border-radius:8px;padding:16px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    h2{margin:6px 0 12px;font-size:18px}
    label{display:block;margin-top:8px;font-size:14px}
    input[type=text]{width:100%;padding:8px;font-size:14px;margin-top:6px;border:1px solid #ccc;border-radius:4px}
    button{cursor:pointer;padding:10px 12px;border-radius:8px;border:none;font-weight:700}
    .btn-primary{background:#4682B4;color:white}
    .btn-green{background:var(--accent);color:white}
    .res-box{margin-top:10px;padding:8px;background:#222;color:#fff;border-radius:6px}
    .mode-row{display:flex;gap:12px;align-items:center;margin-bottom:8px}
    .charts-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
    .chart-card{background:#fafafa;padding:8px;border-radius:6px}
    .chart-title{font-size:12px;margin:6px 0}
    .small{font-size:12px}
    @media(max-width:900px){.container{grid-template-columns:1fr;}.charts-grid{grid-template-columns:repeat(2,1fr)}}
  </style>
</head>
<body>
  <div class="container">
    <div class="panel" id="left-panel">
      <h2>Resistance Calculation</h2>
      <label>Length [m]:<input id="length" type="text" value="0.1"></label>
      <label>Radius [m]:<input id="radius" type="text" value="0.001"></label>
      <label>Viscosity [Pa·s]:<input id="viscosity" type="text" value="0.001"></label>
      <button id="calcRes" class="btn-primary" style="margin-top:12px">Calculate Resistance</button>
      <div class="res-box" id="resResult">R = </div>
    </div>

    <div class="panel" id="right-panel">
      <h2>Unified Pressure Calculator (Positive / Negative)</h2>

      <div class="mode-row">
        <div style="font-weight:700">Mode:</div>
        <label><input type="radio" name="mode" value="positive" checked> Positive Pressure</label>
        <label><input type="radio" name="mode" value="negative"> Negative Pressure</label>
      </div>

      <label>Target Pressure [psi gauge]:<input id="Pm" type="text" value="0"></label>
      <label>Time [s]:<input id="time" type="text" value="60"></label>
      <label>User Initial Volume [mL]:<input id="volume" type="text" value="1"></label>
      <label>Resistance [Pa·s/m²]:<input id="R" type="text" value="0.001"></label>

      <button id="genGraph" class="btn-green" style="margin-top:12px">Generate Graph</button>

      <div class="charts-grid" id="chartsGrid"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script>
    const Po_psi = 14.7;
    const Po = Po_psi * 6894.76;
    const MAX_RUNTIME = 7500;
    const MAX_POINTS = 6000;
    const EPS = 1e-10;

    function toNum(v,fallback=0){
      const n = parseFloat(v);
      return isFinite(n) ? n : fallback;
    }

    function nowMs(){ return performance.now(); }

    function solveSecant(func, x0, x1, tol=1e-8, maxIter=600){
      try{
        let f0 = func(x0), f1 = func(x1);
        if(!isFinite(f0) || !isFinite(f1)) return null;
        for(let i=0;i<maxIter;i++){
          if(Math.abs(f1) < tol) return x1;
          const denom = f1 - f0;
          if(Math.abs(denom) < 1e-18) return null;
          const x2 = x1 - f1*(x1-x0)/denom;
          x0 = x1; f0 = f1;
          x1 = x2; f1 = func(x1);
          if(!isFinite(f1)) return null;
        }
        return null;
      } catch(e){ return null; }
    }

    // POSITIVE PRESSURE CURVE
    function calc_curve_positive(Pm_pa, t_sec, R, Vo_ml){
      const start = nowMs();
      const Vo = Vo_ml / 1e6;
      let Pi = Math.max(Pm_pa + 100, Po + 10);
      let Pt = Po + 100;

      function eqn(P, PiL){
        if(P <= Po+EPS || PiL <= Po+EPS) return NaN;
        const A = Math.log(PiL - Po) - Math.log(PiL) + (Po/PiL);
        return Math.log(P-Po)-Math.log(P)+(Po/P)-(Po/(Vo*R))*t_sec - A;
      }

      let attempts = 0;
      while(Pt < Pm_pa){
        if(nowMs()-start > MAX_RUNTIME) throw new Error("Positive: Timeout");
        const sol = solveSecant(p=>eqn(p,Pi), Pm_pa*0.9, Pm_pa*1.01);
        if(sol===null || !isFinite(sol)){ Pi+=20; attempts++; if(attempts>2000) throw "No convergence"; continue; }
        Pt = sol;
        Pi+=20;
      }

      const A = Math.log(Pt-Po)-Math.log(Pt)+(Po/Pt);
      const data=[];
      let P=Pt;
      const dP = 0.01*6894.76;
      let count=0;

      while(P > Po+EPS && count < MAX_POINTS){
        const val = (Math.log(P-Po)-Math.log(P)+(Po/P)) - A;
        const t_graph = -(Vo*R/Po)*val;
        if(isFinite(t_graph)){
          data.push([t_graph, (P-Po)/6894.76]);
        }
        P-=dP;
        count++;
      }

      if(data.length===0) data.push([0,(Pt-Po)/6894.76]);
      if(data[data.length-1][0] < t_sec){
        const lastP = data[data.length-1][1];
        data.push([t_sec,lastP]);
      }

      const Vf = (Po/Pt)*Vo;
      const dV = (Vo-Vf)*1e6;
      const Pt_g = (Pt/6894.76)-14.7;

      return { data, dV, Pt_g };
    }

    // NEGATIVE PRESSURE CURVE
    function calc_curve_negative(Pm_pa, t_sec, R, Vo_ml){
      const start = nowMs();
      const Vo = Vo_ml/1e6;
      let Pi = Math.min(Pm_pa - 100, Po - 10);
      let Pt = Po - 100;

      function eqn(P,PiL){
        if(P >= Po-EPS || PiL >= Po-EPS) return NaN;
        const A = Math.log(Po-PiL)-Math.log(Po)+(PiL/Po);
        return Math.log(Po-P)-Math.log(Po)+(P/Po)-(Po/(Vo*R))*t_sec-A;
      }

      let attempts=0;
      while(Pt > Pm_pa){
        if(nowMs()-start>MAX_RUNTIME) throw new Error("Negative: Timeout");
        const sol = solveSecant(p=>eqn(p,Pi), Pm_pa*0.9, Pm_pa*1.05);
        if(sol===null){ Pi-=20; attempts++; if(attempts>2000) throw "No convergence"; continue; }
        Pt = sol;
        Pi-=20;
      }

      const A = Math.log(Po-Pt)-Math.log(Po)+(Pt/Po);
      const data=[];
      let P=Pt;
      let count=0;

      while(P < Po-10 && count<MAX_POINTS){
        const val = (Math.log(Po-P)-Math.log(Po)+(P/Po))-A;
        const t_graph = -(Vo*R/Po)*val;
        if(isFinite(t_graph)){
          data.push([t_graph,(P-Po)/6894.76]);
        }
        P+=500;
        count++;
      }

      if(data.length===0) data.push([0,(Pt-Po)/6894.76]);
      if(data[data.length-1][0] < t_sec){
        const lastP = data[data.length-1][1];
        data.push([t_sec,lastP]);
      }

      const Vf=(Po/Pt)*Vo;
      const dV=Math.abs(Vo-Vf)*1e6;
      const Pt_g=(Pt/6894.76)-14.7;
      return {data,dV,Pt_g};
    }

    // ------- UI + Graphs --------
    let chartInstances=[];

    function clearCharts(){
      chartInstances.forEach(c=>c.destroy());
      chartInstances=[];
      const g=document.getElementById('chartsGrid');
      g.innerHTML="";
      for(let i=0;i<6;i++){
        const card=document.createElement('div');
        card.className='chart-card';
        const title=document.createElement('div');
        title.className='chart-title small';
        title.textContent='Vo=...';
        const canvas=document.createElement('canvas');
        canvas.id='chart'+i;
        canvas.height=200;
        card.appendChild(title);
        card.appendChild(canvas);
        g.appendChild(card);
      }
    }

    clearCharts();

    // Resistance
    document.getElementById('calcRes').addEventListener('click',()=>{
      const L = toNum(lengthEl.value);
      const r = toNum(radiusEl.value);
      const mu = toNum(viscosityEl.value);
      if(L<=0||r<=0||mu<=0) return alert("Invalid");
      const Rval = (8*mu*L)/(Math.PI*r**4);
      resResult.textContent = `R = ${Rval.toExponential(3)} Pa·s/m²`;
      REl.value = Rval.toExponential(3);
    });

    const lengthEl=document.getElementById('length'),
          radiusEl=document.getElementById('radius'),
          viscosityEl=document.getElementById('viscosity'),
          resResult=document.getElementById('resResult'),
          REl=document.getElementById('R');

    // -------- Main Graph Button ----------
    document.getElementById('genGraph').addEventListener('click',()=>{
      try{
        const Pm_g = toNum(document.getElementById('Pm').value);
        const t = toNum(document.getElementById('time').value);
        const tCutoff = t+60;
        const Vo_user = toNum(document.getElementById('volume').value);
        const Rval = toNum(document.getElementById('R').value);
        const mode = document.querySelector("input[name='mode']:checked").value;

        const Pm_abs = (Po_psi + Pm_g)*6894.76;

        clearCharts();
        const vols=[Vo_user,5,10,15,20,25];

        vols.forEach((vol,idx)=>{
          const ctx=document.getElementById("chart"+idx).getContext("2d");
          const titleDiv = ctx.canvas.parentNode.querySelector(".chart-title");
          try{
            let result = (mode==="positive")
              ? calc_curve_positive(Pm_abs,t,Rval,vol)
              : calc_curve_negative(Pm_abs,t,Rval,vol);

            // STRICT FILTER: remove invalids before axis scaling
            let data = result.data.filter(
              d => isFinite(d[0]) && isFinite(d[1]) && Math.abs(d[1])<1e6
            );

            if(data.length===0) throw new Error("No usable data");

            // Limit to cutoff
            data = data.filter(d=>d[0]<=tCutoff);
            if(data.length===0) throw new Error("No points inside time window");

            // Sort
            data.sort((a,b)=>a[0]-b[0]);

            // Reduce if too many
            if(data.length>MAX_POINTS){
              const step=Math.ceil(data.length/MAX_POINTS);
              data=data.filter((_,i)=>i%step===0);
            }

            // Build arrays
            const points = data.map(d=>({x:d[0],y:d[1]}));
            const pressures = points.map(p=>p.y);

            // Compute solid min/max
            const yMin = Math.min(...pressures);
            const yMax = Math.max(...pressures);

            const padding = 0.1*(yMax - yMin || 1);

            titleDiv.textContent =
              `Vo=${vol} mL | ΔV=${result.dV.toFixed(3)} mL | Pi=${result.Pt_g.toFixed(2)} psi`;

            const chart = new Chart(ctx,{
              type:"line",
              data:{datasets:[{
                data:points,
                borderWidth:1.2,
                tension:0.2,
                pointRadius:0
              }]},
              options:{
                parsing:false,
                responsive:true,
                maintainAspectRatio:false,
                scales:{
                  x:{
                    type:"linear",
                    min:0,
                    max:tCutoff,
                    title:{display:true,text:"t (s)"}
                  },
                  y:{
                    title:{display:true,text:"P (psi)"},
                    min:yMin-padding,
                    max:yMax+padding,
                    ticks:{
                      autoSkip:true,
                      maxTicksLimit:7
                    }
                  }
                }
              }
            });

            chartInstances.push(chart);

          } catch(e){
            titleDiv.textContent="Failed: "+e.message;
            ctx.fillStyle="red";
            ctx.fillText("Failed: "+e.message,10,50);
          }
        });

      } catch(e){
        alert("Error: "+e.message);
      }
    });
  </script>
</body>
</html>
