<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unified Pressure Calculator + Resistance Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.min.css" rel="stylesheet">

  <style>
    :root {
      --bg: #f4f7fb;
      --accent: #2a7f4f; /* darker green button */
    }

    body {
      font-family: 'Times New Roman', Times, serif;
      background: var(--bg);
      margin: 0;
      padding: 20px;
      font-size: 18px;
    }

    /* Skip Link */
    .skip-link {
      position: absolute;
      top: -40px;
      left: 10px;
      background: black;
      color: white;
      padding: 8px 14px;
      border-radius: 6px;
      text-decoration: none;
      z-index: 1000;
      font-size: 18px;
    }
    .skip-link:focus {
      top: 10px;
    }

    h1, h2 {
      font-size: 24px;
      margin-bottom: 14px;
    }

    /* Containers */
    .calc-container {
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: 20px;
      align-items: start;
      margin-bottom: 30px;
    }

    .panel {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
    }

    label {
      display: block;
      margin-top: 12px;
      font-size: 18px;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px;
      font-size: 18px;
      margin-top: 6px;
      border: 3px solid #444;
      border-radius: 6px;
    }

    button {
      padding: 12px 16px;
      font-size: 18px;
      font-weight: 700;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 14px;
    }

    .btn-primary {
      background: #1E3E66;
      color: white;
    }

    .btn-green {
      background: var(--accent);
      color: white;
    }

    .res-box {
      margin-top: 14px;
      padding: 12px;
      background: #222;
      color: #fff;
      border-radius: 6px;
    }

    .mode-row {
      display: flex;
      align-items: center;
      gap: 14px;
      margin-bottom: 10px;
    }

    /* NEW GRAPH AREA — bigger graphs */
    #graphs-section {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
      margin-top: 30px;
    }

    #chartsGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(420px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .chart-card {
      background: #fafafa;
      padding: 14px;
      border-radius: 10px;
      height: 380px;         /* larger chart box */
      display: flex;
      flex-direction: column;
    }

    .chart-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chart-card canvas {
      width: 100% !important;
      height: 100% !important;
      max-height: 100% !important;
    }

    @media(max-width: 900px) {
      .calc-container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>

<a href="#main" class="skip-link">Skip to main content</a>

<main id="main">

<h1>Welcome to this page</h1>

<!-- ==========================
     CALCULATORS SECTION
     ========================== -->
<div class="calc-container">

  <!-- LEFT PANEL -->
  <div class="panel">
    <h2>Resistance Calculation</h2>

    <label>Length [m]:<input id="length" type="text" value="0.1"></label>
    <label>Radius [m]:<input id="radius" type="text" value="0.001"></label>
    <label>Viscosity [Pa·s]:<input id="viscosity" type="text" value="0.001"></label>

    <button id="calcRes" class="btn-primary">Calculate Resistance</button>

    <div class="res-box" id="resResult">R = </div>
  </div>

  <!-- RIGHT PANEL -->
  <div class="panel">
    <h2>Unified Pressure Calculator (Positive / Negative)</h2>

    <div class="mode-row">
      <strong>Mode:</strong>
      <label><input type="radio" name="mode" value="positive" checked> Positive</label>
      <label><input type="radio" name="mode" value="negative"> Negative</label>
    </div>

    <label>Target Pressure [psi gauge]:<input id="Pm" type="text" value="0"></label>
    <label>Time [s]:<input id="time" type="text" value="60"></label>
    <label>User Initial Volume [mL]:<input id="volume" type="text" value="1"></label>
    <label>Resistance [Pa·s/m²]:<input id="R" type="text" value="0.001"></label>

    <button id="genGraph" class="btn-green">Generate Graph</button>
  </div>

</div>

<!-- ==========================
     NEW LARGE GRAPH SECTION
     ========================== -->
<div id="graphs-section" class="panel">
  <h2>Generated Graphs</h2>
  <div style="font-size:1px; color:#f4f7fb; margin:0; padding:0;">Andrew Untalan</div>
  <div id="chartsGrid"></div>
</div>

</main>


<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<!-- Your JS kept intact except for graph container relocation -->
<script>
/* ENTIRE ORIGINAL JAVASCRIPT UNCHANGED BELOW
   EXCEPT: chartsGrid now refers to the new bottom section.
*/

/* ---------------- CONSTANTS ---------------- */
const Po_psi = 14.7;
const Po = Po_psi * 6894.76;
const MAX_RUNTIME = 8000;

function toNum(v, fallback = 0){
  const n = parseFloat(v);
  return isFinite(n) ? n : fallback;
}

/* (ALL YOUR ORIGINAL JS CONTINUES UNCHANGED) */

/* ---------------- CHART GRID SETUP ---------------- */
function createEmptyGrid(){
  const grid = document.getElementById("chartsGrid");
  grid.innerHTML = "";
  for(let i=0;i<6;i++){
    const card = document.createElement("div");
    card.className = "chart-card";

    const title = document.createElement("div");
    title.className = "chart-title";
    title.id = "title" + i;
    title.textContent = "Vo=... | ΔV=... | Pt=...";

    const canvas = document.createElement("canvas");
    canvas.id = "chart" + i;

    card.appendChild(title);
    card.appendChild(canvas);
    grid.appendChild(card);
  }
}

createEmptyGrid();
/* ------------------ SECANT SOLVER --------------------- */
function solveSecant(func, x0, x1, tol = 1e-6, maxIter = 2000){
  let f0 = func(x0), f1 = func(x1);
  for(let i=0;i<maxIter;i++){
    if(Math.abs(f1) < tol) return x1;
    if(Math.abs(f1 - f0) < 1e-14) break;
    const x2 = x1 - f1*(x1-x0)/(f1-f0);
    x0 = x1; f0 = f1;
    x1 = x2; f1 = func(x1);
  }
  return null;
}

/* ------------------ POSITIVE / NEGATIVE CURVE CALCS --------------------- */

function calc_curve_positive(Pm, t, R, Vo_ml){
  const start = performance.now();
  const Vo = Vo_ml / 1e6;
  let Pi = Pm + 0.01, Pt = 0.1;

  function eqn(P, PiL){
    const A = Math.log(PiL - Po) - Math.log(PiL) + (Po / PiL);
    return Math.log(P - Po) - Math.log(P) + (Po / P) - (Po / (Vo * R)) * t - A;
  }

  let step = 0;
  while(Pt < Pm){
    if(performance.now() - start > MAX_RUNTIME) throw new Error("Timeout");
    const sol = solveSecant(p => eqn(p, Pi), Pm * 0.9, Pm * 1.01);
    if(sol === null || !isFinite(sol)){
      Pi += 0.01;
      if(++step > 20000) throw new Error("No convergence");
      continue;
    }
    Pt = sol;
    Pi += 0.01;
    if(++step > 20000) throw new Error("No convergence");
  }

  const A = Math.log(Pt - Po) - Math.log(Pt) + (Po / Pt);

  const data = [];
  let P = Pt;
  const dP = 0.01 * 6894.76;

  while(P > (Pi - (2 * 6894.76))){
    const t_graph = -(Vo * R / Po) * ((Math.log(P - Po) - Math.log(P) + (Po / P)) - A);
    data.push([t_graph, (P - Po) / 6894.76]);
    P -= dP;
    if(data.length > 20000) break;
  }

  if(data.length === 0) data.push([0, (Pt - Po) / 6894.76]);
  if(data[data.length - 1][0] < t){
    const lastP = data[data.length - 1][1];
    data.push([t, lastP]);
  }

  const Vf = (Po / Pt) * Vo;
  const dV = (Vo - Vf) * 1e6;
  const Pt_g = (Pt / 6894.76) - 14.7;

  return { data, dV, Pt_g };
}

function calc_curve_negative(Pm, t, R, Vo_ml){
  const start = performance.now();
  const Vo = Vo_ml / 1e6;
  let Pi = Pm - 0.01, Pt = Po - 100;

  function eqn(P, PiL){
    const A = Math.log(Po - PiL) - Math.log(Po) + (PiL / Po);
    return Math.log(Po - P) - Math.log(Po) + (P / Po) - (Po / (Vo * R)) * t - A;
  }

  let step = 0;
  while(Pt > Pm){
    if(performance.now() - start > MAX_RUNTIME) throw new Error("Timeout");
    const sol = solveSecant(p => eqn(p, Pi), Pm * 0.9, Pm * 1.05);
    if(sol === null || !isFinite(sol)){
      Pi -= 0.01;
      if(++step > 20000) throw new Error("No convergence");
      continue;
    }
    Pt = sol;
    Pi -= 0.01;
    if(++step > 20000) throw new Error("No convergence");
  }

  const A = Math.log(Po - Pt) - Math.log(Po) + (Pt / Po);

  const data = [];
  let P = Pt;

  while(P < Po - 500){
    const t_graph = -(Vo * R / Po) * ((Math.log(Po - P) - Math.log(Po) + (P / Po)) - A);
    data.push([t_graph, (P - Po) / 6894.76]);
    P += 500;
    if(data.length > 20000) break;
  }

  if(data.length === 0) data.push([0, (Pt - Po) / 6894.76]);
  if(data[data.length - 1][0] < t){
    const lastP = data[data.length - 1][1];
    data.push([t, lastP]);
  }

  const Vf = (Po / Pt) * Vo;
  const dV = Math.abs(Vo - Vf) * 1e6;
  const Pt_g = (Pt / 6894.76) - 14.7;

  return { data, dV, Pt_g };
}

/* ------------------ CHART MANAGEMENT --------------------- */
let chartInstances = [];

function destroyAllCharts(){
  chartInstances.forEach(c => {
    try{ c.destroy(); } catch(e){ /* ignore */ }
  });
  chartInstances = [];
}

function createEmptyGrid(){
  const grid = document.getElementById("chartsGrid");
  grid.innerHTML = "";
  for(let i=0;i<6;i++){
    const card = document.createElement("div");
    card.className = "chart-card";

    const title = document.createElement("div");
    title.className = "chart-title";
    title.id = "title" + i;
    title.textContent = "Vo=... | ΔV=... | Pt=...";

    const canvas = document.createElement("canvas");
    canvas.id = "chart" + i;

    card.appendChild(title);
    card.appendChild(canvas);
    grid.appendChild(card);
  }
}

createEmptyGrid();

/* ------------------ RESISTANCE BUTTON --------------------- */
document.getElementById("calcRes").onclick = () => {
  const L = toNum(document.getElementById("length").value);
  const r = toNum(document.getElementById("radius").value);
  const mu = toNum(document.getElementById("viscosity").value);

  if(L <= 0 || r <= 0 || mu <= 0){
    alert("Invalid inputs.");
    return;
  }

  const R = (8 * mu * L) / (Math.PI * r ** 4);
  document.getElementById("resResult").textContent = `R = ${R.toExponential(3)} Pa·s/m²`;
  document.getElementById("R").value = R.toExponential(3);
};

/* ------------------ MAIN GRAPH GENERATION (SYNCHRONIZED Y-AXIS) --------------------- */
document.getElementById("genGraph").onclick = () => {
  const Pm_g = toNum(document.getElementById("Pm").value);
  const t = toNum(document.getElementById("time").value);
  const Vo_user = toNum(document.getElementById("volume").value);
  const R = toNum(document.getElementById("R").value);
  const mode = document.querySelector("input[name='mode']:checked").value;

  // Convert gauge psi to absolute pressure (Pa)
  const Pm_abs = (Po_psi + Pm_g) * 6894.76;
  const tCutoff = t + 60; // provide a little extension on x axis

  destroyAllCharts();
  createEmptyGrid();

  const vols = [Vo_user, 5, 10, 15, 20, 25];

  // First pass: compute all datasets and collect global min/max
  const datasets = [];
  let globalMin = Infinity;
  let globalMax = -Infinity;

  for(let i=0;i<vols.length;i++){
    const vol = vols[i];
    const titleEl = document.getElementById("title" + i);
    const ctxEl = document.getElementById("chart" + i);
    try{
      const result = mode === "positive"
        ? calc_curve_positive(Pm_abs, t, R, vol)
        : calc_curve_negative(Pm_abs, t, R, vol);

      let data = result.data.filter(d => isFinite(d[0]) && isFinite(d[1]) && d[0] <= tCutoff);
      if(data.length === 0) throw new Error("No data generated");

      data.sort((a,b) => a[0] - b[0]);
      const pts = data.map(d => ({ x: d[0], y: d[1] }));

      // compute local min/max
      const pressures = pts.map(p => p.y);
      const ymin = Math.min(...pressures);
      const ymax = Math.max(...pressures);

      // update global min/max
      if(ymin < globalMin) globalMin = ymin;
      if(ymax > globalMax) globalMax = ymax;

      datasets.push({
        index: i,
        vol,
        pts,
        dV: result.dV,
        Pt_g: result.Pt_g
      });

    }catch(err){
      // store a marker so we can show an error later for this card
      datasets.push({
        index: i,
        vol,
        error: err.message
      });
      // don't let one error break global min/max, but provide a fallback range later
    }
  }

  // If no valid data at all, show errors and stop
  const anyValid = datasets.some(ds => ds.pts && ds.pts.length > 0);
  if(!anyValid){
    datasets.forEach(ds => {
      const titleEl = document.getElementById("title" + ds.index);
      const canvas = document.getElementById("chart" + ds.index);
      if(ds.error){
        titleEl.textContent = "Error: " + ds.error;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "red";
        ctx.font = "14px serif";
        ctx.fillText("Error: " + ds.error, 10, 50);
      } else {
        titleEl.textContent = "No data";
      }
    });
    return;
  }

  // Compute padding based on global range (10% of range)
  if(!isFinite(globalMin) || !isFinite(globalMax)){
    // fallback
    globalMin = -10;
    globalMax = 10;
  }
  let globalRange = globalMax - globalMin;
  if(globalRange === 0){
    // avoid zero range, give small range centered on value
    globalRange = Math.abs(globalMax) || 1;
    globalMin = globalMin - globalRange*0.1;
    globalMax = globalMax + globalRange*0.1;
    globalRange = globalMax - globalMin;
  }
  const pad = 0.1 * globalRange;
  const yMinFinal = globalMin - pad;
  const yMaxFinal = globalMax + pad;

  // Second pass: create charts with the same y-axis (yMinFinal, yMaxFinal)
  datasets.forEach(ds => {
    const titleEl = document.getElementById("title" + ds.index);
    const canvas = document.getElementById("chart" + ds.index);
    const ctx = canvas.getContext("2d");

    if(ds.error){
      titleEl.textContent = "Error: " + ds.error;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "red";
      ctx.font = "14px serif";
      ctx.fillText("Error: " + ds.error, 10, 50);
      return;
    }

    const dVf = ds.dV !== undefined ? ds.dV.toFixed(3) : "...";
    const Ptf = ds.Pt_g !== undefined ? ds.Pt_g.toFixed(3) : "...";
    titleEl.textContent = `Vo=${ds.vol} mL | ΔV=${dVf} mL | Pt=${Ptf} psi`;

    const chart = new Chart(ctx, {
      type: "line",
      data: {
        datasets: [{
          data: ds.pts,
          borderWidth: 1.2,
          tension: 0.18,
          pointRadius: 0,
          parsing: false
        }]
      },
      options: {
        responsive: false,
        maintainAspectRatio: false,
        parsing: false,
        plugins: {
          legend: { display: false }
        },
        scales: {
          x: {
            type: "linear",
            min: 0,
            max: tCutoff,
            title: { display: true, text: "t (s)" }
          },
          y: {
            min: yMinFinal,
            max: yMaxFinal,
            ticks: { maxTicksLimit: 6 },
            title: { display: true, text: "P (psi)" }
          }
        }
      }
    });

    chartInstances.push(chart);
  });

}; // end onclick
</script>

</body>
</html>
